//! # Task module

use core::{ 
    future::Future, 
    pin::Pin,
    task::{ Context, Poll },
    sync::atomic::{ AtomicU64, Ordering },
};
use alloc::boxed::Box;

pub mod executor;
pub mod simple_executor;
pub mod keyboard;

// A newtype wrapper around a pinned, heap allocated, and dynamically dispatched
// future with the empty type `()` as output.
pub struct Task {
    // This field makes it possible to uniquely name a task, which is required
    // for waking a specific task.
    id: TaskId,
    future: Pin<Box<dyn Future<Output = ()>>>,
}

impl Task {
    // Create a new Task structs from futures.
    //
    // The `'static` lifetime is required here because the returned `Task` can
    // live for an arbitrary time, so the future needs to be valid for that time
    // too.
    pub fn new(future: impl Future<Output = ()> + 'static) -> Task {
        Task {
            id: TaskId::new(),
            // Pins `future` in memory.
            future: Box::pin(future),
        }
    }

    // Allow the executor to poll the stored future.
    fn poll(&mut self, context: &mut Context) -> Poll<()> {
        // Since the `poll` method of the `Future` trait expects to be called on
        // a `Pin<&mut T>` type, we use the `Pin::as_mut` method to convert the
        // `self.future` field of type `Pin<Box<T>>` first. Then we `call` poll
        // on the converted `self.future` field and return the result. Since the
        // `Task::poll` method should be only called by the executor, we keep
        // the function private to the `task` module.
        self.future.as_mut().poll(context)
    }
}

// Gives each task an unique ID. This is required because we need a way to
// specify which task should be woken.
//
// The `TaskId` struct is a simple wrapper type around `u64`. The sortable trait
// is important because we want to use `TaskId` as the key type of a `BTreeMap`.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
struct TaskId(u64);

impl TaskId {
    fn new() -> Self {
        // Ensure that each ID is assigned only once.
        static NEXT_ID: AtomicU64 = AtomicU64::new(0);
        // The fetch_add method atomically increases the value and returns the
        // previous value in one atomic operation. This means that even when the
        // TaskId::new method is called in parallel, every ID is returned
        // exactly once.
        //
        // The Ordering parameter defines whether the compiler is allowed to
        // reorder the fetch_add operation in the instructions stream. Since we
        // only require that the ID is unique, the Relaxed ordering with the
        // weakest requirements is enough in this case.
        TaskId(NEXT_ID.fetch_add(1, Ordering::Relaxed))
    }
}

// ********** SIdenote **********
//
// # Implementation
//
// ## Task
//
// The `Task` struct is a newtype wrapper around a pinned, heap allocated, and
// dynamically dispatched future with the empty type `()` as output. Let’s go
// through it in detail:
// - We require that the future associated with a task returns `()`. This means
//   that tasks don’t return any result, they are just executed for its side
//   effects. For example, the `example_task` function we defined in `main.rs`
//   has no return value, but it prints something to the screen as a side
//   effect.
// - The `dyn` keyword indicates that we store a trait object in the Box. This
//   means that the methods on the future are dynamically dispatched, which
//   makes it possible to store different types of futures in the Task type.
//   This is important because each `async fn` has its own type and we want to
//   be able to create multiple different tasks.
// - The `Pin<Box>` type ensures that a value cannot be moved in memory by
//   placing it on the heap and preventing the creation of `&mut` references to
//   it. This is important because futures generated by async/await might be
//   self-referential, i.e. contain pointers to itself that would be invalidated
//   when the future is moved.
//
// ## Executor with Waker Support
//
// To fix the performance problem, we need to create an executor that properly
// utilizes the `Waker` notifications. This way, the executor is notified when
// the next keyboard interrupt occurs, so it does not need to keep polling the
// `print_keypresses` task over and over again.
//
// ### Task Id
//
// The first step in creating an executor with proper support for waker
// notifications is to give each task an unique ID. This is required because we
// need a way to specify which task should be woken.
